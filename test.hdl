not (a b) => (output) {
    nand [a a] [output] 
}

and (a b) => (output) {
    nand [a b] [c]
    not [c] [output]
}

or (a b) => (output) {
    not [a] [not_a]
    not [b] [not_b]
    nand [not_a not_b] [output]
}

xor (a b) => (output) {
    not [a] [not_a]
    not [b] [not_b]
    and [a not_b] [a_notb]
    and [b not_a] [notb_a]
    or [a_notb notb_a] [output]
}

half_adder (a b) => (sum carry) {
    xor [a b] [sum]
    and [a b] [carry]
}

full_adder (a b carry_in) => (sum carry_out) {
    half_adder [a b] [s1 c1]
    half_adder [carry_in s1] [sum c2]
    or [c1 c2] [carry_out]
}

4adder (a0 a1 a2 a3 b0 b1 b2 b3 carry_in) => (s0 s1 s2 s3 carry_out) {
    full_adder [a0 b0 carry_in] [s0 c0]
    full_adder [a1 b1 c0] [s1 c1]
    full_adder [a2 b2 c1] [s2 c2]
    full_adder [a3 b3 c2] [s3 carry_out]
}

2x1mux (a b s) => (output) {
    not [s] [not_s]
    and [a not_s] [a_nots]
    and [b s] [b_s]
    or [a_nots b_s] [output]
}

4x1mux (i0 i1 i2 i3 s0 s1) => (output) {
    2x1mux [i0 i1 s0] [o0]
    2x1mux [i2 i3 s0] [o1]
    2x1mux [o0 o1 s1] [output] 
}

8x1mux (i0 i1 i2 i3 i4 i5 i6 i7 s0 s1 s2) => (output) {
    4x1mux [i0 i1 i2 i3 s0 s1] [o0]
    4x1mux [i4 i5 i6 i7 s0 s1] [o1]
    2x1mux [o0 o1 s2] [output]
}

my_chip () => () {
    input_chip [] [i0 i1 i2 i3 i4 i5 i6 i7 s0 s1 s2]
    8x1mux [i0 i1 i2 i3 i4 i5 i6 i7 s0 s1 s2] [out]
    output_chip [out] []
}

RUN my_chip

# my_chip (a0 a1 a2 a3 b0 b1 b2 b3) => () {
#     4adder [a0 a1 a2 a3 b0 b1 b2 b3] [s0 s1 s2 s3 carry_out]
#     decimal_output_chip [s0 s1 s2 s3 carry_out] []
#     output_chip [s0 s1 s2 s3 carry_out] []
# }

#RUN my_chip 1 0 0 1 1 0 0 0
